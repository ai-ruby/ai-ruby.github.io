[{"title":"移动端弹窗滑动引起底部body窗体滚动的bug处理","date":"2018-08-17T03:20:38.329Z","path":"/posts/移动端的bug/","text":"浮层滚动阻止window窗体滚动的bug处理 前言 关于弹窗滑动会引起底部body滚动这个bug,上网找了好久也没有一个特别好的解决方法,终于在张老师的网站里终于看到了希望,哈哈,于是就有了这篇文章.具体实现代码就是都是张老师的文章web移动端浮层滚动阻止window窗体滚动JS/CSS处理 看了网上的案例做法是:弹窗出现的时候,设置body属性 overflow:hidden,记录下当前body滑动的scrollTop,然后在弹窗消失之后,把这个scrollTop赋值到body的scrollTop,这样的做法,在弹窗消失的时候,body窗口就会滚动下再回到你指定的scrollTop上.动弹的效果令人无法接受 张老师的做法呢虽然也有把body设置为overflow:hidden,但是同时把弹窗禁止了滑动,监听弹窗需要滑动区域的touchstart和touchmove等touch事件,具体实现,看以下代码吧 以下代码都是参照张老师网址代码 web移动端浮层滚动阻止window窗体滚动JS/CSS处理如有冒犯请联系本人 阻止移动端弹窗滚动引起底部body滚动处理 在css上,在html标签上添加一个类 1234567.noscroll,.noscroll body &#123; overflow: hidden;&#125;.noscroll body &#123; position: relative;&#125; 弹窗出来,添加类 1$(&apos;html&apos;).addClass(&apos;noscroll&apos;); 弹窗消失,移除类 1$(&apos;html&apos;).removeClass(&apos;noscroll&apos;); 调用方法 第一个参数是传对应弹窗对象. eg:$(‘#aside’) 第二个参数是传弹窗滚动的类名. eg:’.scrollable’ 123$.smartScroll(container, selectorScrollable);eg: $.smartScroll($(&apos;#aside&apos;), &apos;.scrollable&apos;); 实例代码html和css代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;移动端浮层内部滚动窗体不滚动的JS处理&lt;/title&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;style&gt;.button &#123; display: block; width: 240px; line-height: 30px; margin: 20px auto; background-color: #cd0000; color: #fff; text-align: center;&#125;.button:hover &#123; text-decoration: none;&#125;.aside,.aside-overlay &#123; position: fixed; top: 0; right: 0; bottom: 0; left: 0;&#125;.aside &#123; -webkit-transition: visibility .25s; transition: visibility .25s; z-index: 3; visibility: hidden; overflow: hidden;&#125;.aside.active &#123; -webkit-transition: none; transition: none; visibility: visible;&#125;.aside-overlay &#123; background-color: black; opacity: 0; -webkit-transition: opacity .25s; transition: opacity .25s;&#125;.active&gt;.aside-overlay &#123; opacity: .6;&#125;.aside .module-footer &#123; position: absolute; left: 0; right: 0; bottom: 0;&#125;.aside .module-header &#123; position: absolute; left: 0; right: 0; top: 0;&#125;.aside .module-main &#123; position: absolute; left: 0; right: 0; top: 44px; bottom: 92px; overflow: auto; -webkit-overflow-scrolling: touch;&#125;.aside .scrollable &#123; overflow: auto; -webkit-overflow-scrolling: touch;&#125;.aside-content &#123; position: absolute; bottom: 0; right: 0; background-color: white; -webkit-transition: transform .15s; transition: transform .15s; left: 60px; top: 0; height: 60%; -webkit-transform: translateX(100%); transform: translateX(100%);&#125;.active&gt;.aside-content &#123; -webkit-transform: translate(0%, 0%); transform: translate(0%, 0%);&#125;aside a:hover &#123; text-decoration: none;&#125;.noscroll,.noscroll body &#123; overflow: hidden;&#125;.noscroll body &#123; position: relative;&#125;&lt;/style&gt;&lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;h1&gt;移动端浮层内滚动窗体不滚动的JS处理&lt;/h1&gt; &lt;button id=&quot;button&quot; class=&quot;button&quot;&gt;点我出弹窗哦&lt;/button&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;我是body底部......&lt;/p&gt; &lt;p&gt;body底部......到底啦&lt;/p&gt; &lt;p&gt;body底部......到底啦&lt;/p&gt; &lt;p&gt;body底部......到底啦&lt;/p&gt; &lt;/div&gt; &lt;aside id=&quot;aside&quot; class=&quot;aside&quot;&gt; &lt;i class=&quot;aside-overlay hideAside&quot;&gt;&lt;/i&gt; &lt;div class=&quot;aside-content&quot;&gt; &lt;div class=&quot;module module-filter-list&quot;&gt; &lt;div class=&quot;module-header&quot;&gt; 弹窗固定头部 &lt;/div&gt; &lt;div class=&quot;module-main scrollable&quot;&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;我是弹窗里可以滚动的部分哦&lt;/p&gt; &lt;p&gt;弹窗滚动到底啦......&lt;/p&gt; &lt;p&gt;弹窗滚动到底啦......&lt;/p&gt; &lt;p&gt;弹窗滚动到底啦......&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;module-footer&quot;&gt; &lt;nav class=&quot;btn-group&quot;&gt; 弹窗固定底部 &lt;/nav&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/aside&gt;&lt;/body&gt;&lt;/html&gt; js代码 注意:调用参数的,具体看回上面的调用方法 123456789101112131415161718var elButton = $(&apos;#button&apos;), elButtonWith = $(&apos;#buttonWith&apos;);var elAside = $(&apos;#aside&apos;);elButton.on(&apos;click&apos;, function() &#123; elAside.addClass(&apos;active&apos;); $(&apos;html&apos;).addClass(&apos;noscroll&apos;);&#125;);elButtonWith.on(&apos;click&apos;, function() &#123; elAside.addClass(&apos;active&apos;); $.smartScroll(elAside, &apos;.scrollable&apos;); elButton.html(elButton.html().replace(&apos;没有&apos;, &apos;已经&apos;)); $(&apos;html&apos;).addClass(&apos;noscroll&apos;);&#125;);$(&apos;.hideAside&apos;).on(&apos;click&apos;, function() &#123; $(&apos;html&apos;).removeClass(&apos;noscroll&apos;); elAside.removeClass(&apos;active&apos;);&#125;); 关键代码 smartScroll 具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103$.smartScroll = function(container, selectorScrollable) &#123; // 如果没有滚动容器选择器，或者已经绑定了滚动时间，忽略 if (!selectorScrollable || container.data(&apos;isBindScroll&apos;)) &#123; return; &#125; // 是否是搓浏览器 // 自己在这里添加判断和筛选 var isSBBrowser; var data = &#123; posY: 0, maxscroll: 0 &#125;; // 事件处理 container.on(&#123; touchstart: function(event) &#123; var events = event.touches[0] || event; // 先求得是不是滚动元素或者滚动元素的子元素 var elTarget = $(event.target); if (!elTarget.length) &#123; return; &#125; console.log(elTarget, elTarget.parents(selectorScrollable)) var elScroll; // 获取标记的滚动元素，自身或子元素皆可 if (elTarget.is(selectorScrollable)) &#123; elScroll = elTarget; console.log(11) &#125; else if ((elScroll = elTarget.parents(selectorScrollable)).length == 0) &#123; elScroll = null; console.log(222) &#125; if (!elScroll) &#123; return; &#125; // 当前滚动元素标记 data.elScroll = elScroll; // 垂直位置标记 data.posY = events.pageY; data.scrollY = elScroll.scrollTop(); // 是否可以滚动 data.maxscroll = elScroll[0].scrollHeight - elScroll[0].clientHeight; &#125;, touchmove: function(event) &#123; // console.log(data) // 如果不足于滚动，则禁止触发整个窗体元素的滚动 if (data.maxscroll &lt;= 0 || isSBBrowser) &#123; // 禁止滚动 event.preventDefault(); &#125; // 滚动元素 var elScroll = data.elScroll; // 当前的滚动高度 var scrollTop = elScroll.scrollTop(); // 现在移动的垂直位置，用来判断是往上移动还是往下 var events = event.touches[0] || event; // 移动距离 var distanceY = events.pageY - data.posY; if (isSBBrowser) &#123; elScroll.scrollTop(data.scrollY - distanceY); elScroll.trigger(&apos;scroll&apos;); return; &#125; // 上下边缘检测 if (distanceY &gt; 0 &amp;&amp; scrollTop == 0) &#123; // 往上滑，并且到头 // 禁止滚动的默认行为 event.preventDefault(); return; &#125; // 下边缘检测 if (distanceY &lt; 0 &amp;&amp; (scrollTop + 1 &gt;= data.maxscroll)) &#123; // 往下滑，并且到头 // 禁止滚动的默认行为 event.preventDefault(); return; &#125; &#125;, touchend: function() &#123; data.maxscroll = 0; &#125; &#125;); // 防止多次重复绑定 container.data(&apos;isBindScroll&apos;, true);&#125;;","tags":[{"name":"移动端的bug","slug":"移动端的bug","permalink":"https://ai-ruby.github.io/tags/移动端的bug/"}]},{"title":"git-flow 在初始化仓库时创建功能时报'git flow init'错","date":"2018-08-17T02:33:39.373Z","path":"/posts/git-flow/","text":"git-flow 在初始化仓库时,遇到的坑: Fatal: Not a gitflow-enabled repo yet. Please run ‘git flow init’ first 前言 随着开发团队的壮大,每个写的代码规范等问题,每个人用的git提交都有不同,通过git-flow管理下,可避免一些问题和少做一些操作,更有效开发 初始化仓库 1.用sourceTree的,在菜单栏上点击 sourceTree -&gt;仓库 -&gt; git-flow或 hg flow -&gt; 初始化仓库 这里是development不是develop 2.在命令行 安装git-flow：brew install git-flow git-flow初尝 sourceTree-&gt;仓库-&gt; git-flow或 hg flow-&gt;建立新功能 遇坑1Fatal: Not a gitflow-enabled repo yet. Please run &apos;git flow init&apos; first 解决方法: 1、打开本地项目 .git\\config 文件 mac系统可以按下 shift + command + . 显示隐藏文件即可找到 2、查找gitflow相关的东西删除后保存 如果怕误操作,可以先拷贝一份再操作 3、关闭.git\\config 文件，关闭soureTree 4、重新打开sourceTree，主菜单-&gt;仓库-&gt; git-flow或 hg flow-&gt;初始化仓库，再重新建立新功能即可行 注意: 我这里写的是development不是develop,因为sourceTree有个bug,在初始化和修改config文件都需要改,改成这个后再次打开就没问题了","tags":[{"name":"git","slug":"git","permalink":"https://ai-ruby.github.io/tags/git/"}]},{"title":"vue + canvas + Qrcode","date":"2018-08-17T02:33:39.373Z","path":"/posts/vue-canvas/","text":"在vue里 利用canvas API ,qrcode生成二维码,指定用户名头像,生成一张图片以作分享 前言 之前在vue项目中,要用到canvas, 把用户的头像和用户名的二维码添加一个背景图上生成一张图片用作分享的功能 具体怎么把头像和二维码实现成一张分享图的代码不一一写上来了,具体说下做这个遇到的坑,或许就是能帮助你避免这些踩坑时间了 渲染先后顺序 哪个渲染前,则层级越低,反之越高. 预防把背景图写到最后了,渲染出来的都被背景图挡住就一脸懵逼了 12345678910111213141516171819202122232425262728293031323334353637383940414243// 初始化画布和其他信息const winWid = $(document.body).width()const winH = $(document.body).height()const codeLeft = winWid / 2 - 90const draw = document.getElementById(&apos;image-box&apos;)const ctx = draw.getContext(&apos;2d&apos;)// 图片处理const img = new Image()const codeImg = new Image()const headImg = new Image()// 设置画板宽高img.width = winWiddraw.width = winWiddraw.height = winH * 0.82this.newHeight = draw.heightimg.src = this.initUrlheadImg.src = this.headUrlcodeImg.src = this.codeUrl// 渲染图片img.onload = () =&gt; &#123; // 初始化画布 // 画板处理 ctx.drawImage(img, 0, 0, draw.width, draw.height) // 文字处理 this.textLine(ctx, winWid) // 头像 this.rounderAvar(ctx, headImg) // 二维码 this.roundedRect(ctx, codeLeft + 30, draw.height - 135, 120, 120, 10) ctx.drawImage(codeImg, codeLeft + 40, draw.height - 125, 100, 100) // canvas转换成二进制图片 this.newSrc = draw.toDataURL(&apos;image/png&apos;)&#125; 以上的文字处理和二维码方法都封装了函数,上面的顺序只是说明渲染的顺序 加入二维码插件 生成的二维码后不能注销清除,这样的话,再次生成的二维码还是原来的二维码,新的不能替换旧的 做法: 其实就是把插件生成的二维码隐藏了,把二维码生成的图片赋值一个变量,在canvas渲染的时候,把这个变量放到对应位置,按顺序渲染即可 可能在说的过程中还是不太理解,只有撸了一把才知道坑的所在,所以只能说到那么多了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;template&gt; &lt;div&gt; // 画板 &lt;canvas id=&quot;image-box&quot; width=&quot;100%&quot; height=&quot;911&quot;&gt;Canvas画板&lt;/canvas&gt; // canvas 渲染真正的图片 &lt;img class=&quot;newImg&quot; :src=&quot;newSrc&quot; /&gt; // 插件生成的二维码 &lt;div id=&quot;code&quot; class=&quot;hide&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import QRCode from &apos;qrcodejs2&apos;export default &#123; data: function() &#123; return &#123; newSrc: &apos;&apos;, // 画布生成的图片 codeUrl: &apos;&apos;, // 二维码图片 qrcode: &apos;&apos; // 二维码 &#125; &#125;, mounted() &#123; // 先生成二维码 initQrcode() &#125;, methods: &#123; // 生成二维码 initQrcode() &#123; this.qrcode = new QRCode(&apos;code&apos;, &#123; text: this.link, width: 140, height: 140, colorDark: &apos;#000000&apos;, colorLight: &apos;#ffffff&apos; &#125;) // 将生成二维码的图片赋给 codeUrl this.codeUrl = this.qrcode._el.children[0].toDataURL(&apos;image/png&apos;) &#125;, // 初始化画布 initCanvas: function() &#123; // 初始化画布和其他信息 const winWid = $(document.body).width() const winH = $(document.body).height() const codeLeft = winWid / 2 - 90 const draw = document.getElementById(&apos;image-box&apos;) const ctx = draw.getContext(&apos;2d&apos;) // 图片处理 const img = new Image() const codeImg = new Image() const headImg = new Image() img.width = winWid draw.width = winWid draw.height = winH * 0.82 this.newHeight = draw.height img.src = this.initUrl headImg.src = this.headUrl codeImg.src = this.codeUrl // 二维码图片链接 // 渲染图片 img.onload = () =&gt; &#123; // 初始化画布 // 画板处理 ctx.drawImage(img, 0, 0, draw.width, draw.height) // 文字处理 this.textLine(ctx, winWid) // 头像 this.rounderAvar(ctx, headImg) // 二维码 this.roundedRect(ctx, codeLeft + 30, draw.height - 135, 120, 120, 10) ctx.drawImage(codeImg, codeLeft + 40, draw.height - 125, 100, 100) // canvas转换成二进制图片 this.newSrc = draw.toDataURL(&apos;image/png&apos;) &#125; &#125;, destroyed() &#123; this.codeUrl = &apos;&apos; this.qrcode.clear() &#125; &#125;&lt;/script&gt;","tags":[{"name":"canvas","slug":"canvas","permalink":"https://ai-ruby.github.io/tags/canvas/"}]},{"title":"canvas 邀请卡实战","date":"2018-08-16T09:20:54.342Z","path":"/posts/canvas邀请卡实战/","text":"利用canvas API 将 邀请卡 生成图片,可预览|下载单图|下载多图 前言 canvas是html5提供的一个新的功能,就是一个画布,JavaScript就像一个画笔,帮你描绘出你想要的画面,再叫上 css3新属性, 加上transtion等属性,分分动起来也是可以的. 之前学到canvas时只是在 w3scholl学到的一些 API用法, 开发过程也没具体怎么用到这个属性.直到前几个月公司想做一个功能,刚好就用上了.这个功能是想将该商城用户的头像取到,并且生成一张图片以便分享.那时候做完后一直想做起笔记,久而久之又把它落下了,直到最近看到一个更加有趣的,接近度和我那个项目的有点像,所以就有了这样的笔记了. 关于基础用法,可以看canvas的 API, 之后有可能会写下来.这个笔记呢主要是关于用canvas生成图片并且下载的实战 具体代码参考 掘金文章 canvas入门实战 踩坑 为什么要先说踩坑呢?因为是挽回你复制好代码想要撸一番代码却没有成功的失落感啊! canvas 跨域问题 现象: 在使用canvas的toDataURL()方法时，控制台有时会报错：Uncaught DOMException: Failed to execute ‘toDataURL’ on ‘HTMLCanvasElement’: Tainted canvases may not be exported. 原因: 这是由于之前由drawImage（）向canvas导入的图片跨域而导致的. 解决: 必须保证是在同一个服务器上操作,如果本地有开启服务器的,那直接打开你指向端口的localhost就好了,如果没有,那只能放在线上的服务器继续下面的代码了 在网上搜索所在引用图片之前打开跨域资源就可以解决,代码如下: 123456var image = new Image();image.setAttribute(&quot;crossOrigin&quot;, &apos;Anonymous&apos;); // 解决跨域 // 或者img.crossOrigin=&quot;anonymous&quot;; // 解决跨域img.src=&quot;图片地址&quot;; 但是在本地没有开启服务器之前加了这句话还是会报错的,只有选了图片之后再去操作预览或下载等功能就不会报错.我想是不是重新选择图片之后,这时候的图片链接就是当前同一个服务器地址一致才不会有问题,后来把项目加入服务器后就能正常操作了,所以总的来说,项目要在服务器上就没问题了 好了,下面开始说实例了,例外我在原参考文章的代码中,添加一个图片是否显示全的功能, 那就开始好好的撸一场吧! 邀请卡实例 本次代码主要参考 掘金文章 canvas入门实战 其中有修改的部分,具体代码解释可以访问此网址 先把布局弄好 html&amp;css代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;下载图片&lt;/title&gt; &lt;style&gt; .set-option &#123; float: left; width: 400px; &#125; .set-option .text &#123; width: 200px; height: 40px; padding-left: 10px; border-radius: 4px; border: 1px solid #ccc; &#125; .set-option td &#123; padding: 10px 0; &#125; .set-option td:first-child &#123; text-align: right; padding-right: 10px; &#125; .set-option p &#123; margin: 0; line-height: 16px; &#125; .check-box &#123; width: 16px; height: 16px; margin: 0; vertical-align: top; &#125; button &#123; width: 200px; height: 50px; border: none; color: #fff; font-size: 16px; cursor: pointer; display: block; margin: 10px auto; &#125; button:hover &#123; opacity: .9; &#125; .btn-all &#123; background: #f90; &#125; .btn-save &#123; background: #09f; &#125; .btn-download &#123; background: #4CAF50; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;div class=&quot;set-option&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;画布尺寸&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; class=&quot;text&quot; id=&quot;size&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;背景图片&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;跟随画布大小,图片则显示画布大小,不填满&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;checkbox&quot; class=&quot;check-box&quot; value=&quot;1&quot; id=&quot;fill&quot;&gt;&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; class=&quot;text&quot; id=&quot;user-name&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名x坐标&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;number&quot; class=&quot;text&quot; id=&quot;text-option-x&quot; /&gt; &lt;/br&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot; class=&quot;check-box&quot; value=&quot;1&quot; id=&quot;is-center-x&quot;&gt;居中显示&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名y坐标&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;number&quot; class=&quot;text&quot; id=&quot;text-option-y&quot; /&gt; &lt;/br&gt; &lt;p&gt; &lt;input type=&quot;checkbox&quot; class=&quot;check-box&quot; value=&quot;1&quot; id=&quot;is-center-y&quot;&gt;居中显示&lt;/p&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名字体大小&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;number&quot; class=&quot;text&quot; id=&quot;text-size&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;文字颜色&lt;/td&gt; &lt;td&gt; &lt;input type=&quot;text&quot; class=&quot;text&quot; id=&quot;text-color&quot; /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;图片类型&lt;/td&gt; &lt;td&gt; &lt;select type=&quot;text&quot; class=&quot;text&quot; id=&quot;img-type&quot;&gt; &lt;option value=&quot;jpg&quot;&gt;jpg&lt;/option&gt; &lt;option value=&quot;png&quot;&gt;png&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;button id=&quot;save-image&quot; class=&quot;btn-save&quot;&gt;效果预览&lt;/button&gt; &lt;button id=&quot;download-img&quot; class=&quot;btn-download&quot;&gt;下载当前图片&lt;/button&gt; &lt;button id=&quot;download-all&quot; class=&quot;btn-all&quot;&gt;批量导出&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;show-canvas&quot;&gt; &lt;canvas width=200 height=200 id=&quot;thecanvas&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; js代码: 首先配置好默认值,有个初始化值 123456789101112131415&lt;script&gt;var option = &#123; img: &apos;./test.png&apos;, width: 500, height: 350, fontSize: &quot;20px Microsoft YaHei&quot;, color: &quot;black&quot;, text: &apos;守候&apos;, imgType: &apos;jpg&apos;, x: 30, y: 30, xCenter: false, yCenter: false,&#125;;&lt;/script&gt; 初始化画布, 只是一个初步效果,后面会加多一些更完整的画布代码 12345678910111213141516171819202122232425262728293031323334353637383940414243//画图function draw(obj) &#123; var canvas = document.getElementById(&quot;thecanvas&quot;); //画布大小 canvas.width = obj.width; canvas.height = obj.height; //设置图片 var img = new Image(); img.src = obj.img; var ctx = canvas.getContext(&quot;2d&quot;); //设置字体的坐标 var _x = obj.x, _y = obj.y; //是否居中显示 if (obj.xCenter) &#123; _x = obj.width / 2; &#125; if (obj.yCenter) &#123; _y = obj.height / 2; &#125; //图片加载后 img.onload = function () &#123; //先画图片 if(option.fill) &#123; ctx.drawImage(img,0, 0, option.width, option.height); &#125; else &#123; ctx.drawImage(img,0, 0); &#125; //设置文字的大小 ctx.font = obj.fontSize; //设置文字的颜色 ctx.fillStyle = obj.color; //设置文字坐标 if (obj.xCenter) &#123; ctx.textAlign = &quot;center&quot;; &#125; //画文字 ctx.fillText(obj.text, _x, _y); &#125;;&#125;window.onload = function () &#123; draw(option);&#125; 动态更改参数 更改尺寸12345678910111213//画布尺寸//获取按钮var size = document.getElementById(&quot;size&quot;);size.addEventListener(&quot;blur&quot;, function() &#123; //根据空格，区分高宽 var _width = parseInt(size.value.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;).split(/\\s+/)[0]), _height = parseInt(size.value.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;).split(/\\s+/)[1]); //把参数的width和height改掉 option.width = _width || 500; option.height = _height || 350; //重新画图 draw(option);&#125;); 更改图片123456789101112131415161718//选择图片//获取图片控件var file = document.getElementById(&quot;file&quot;), imagesFile, imageData;file.addEventListener(&apos;change&apos;, function(e) &#123; //获取图片 imagesFile = e.target.files[0]; //把图片转base64 var reader = new FileReader(); reader.readAsDataURL(imagesFile); //图片加载后 reader.onload = function(e) &#123; //设置option的img属性，再冲洗年绘制 imageData = this.result; option.img = imageData; draw(option); &#125;&#125;); 更改图片大小1234567891011//图片大小//获取按钮var fill = document.getElementById(&quot;fill&quot;);fill.addEventListener(&quot;input&quot;, function() &#123; if (fill.checked) &#123; option.fill = false; &#125; else &#123; option.fill = true; &#125; draw(option);&#125;); 更改用户名1234567//用户名var userName = document.getElementById(&quot;user-name&quot;);userName.addEventListener(&quot;blur&quot;, function() &#123; var _text = userName.value.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;).split(/\\s+/); option.text = _text[0]; draw(option);&#125;); 更改横纵坐标值123456789101112131415161718192021222324252627282930313233343536373839404142434445// 横坐标var optionX = document.getElementById(&quot;text-option-x&quot;);optionX.value = option.x;var optionXCenter = document.getElementById(&quot;is-center-x&quot;);optionX.addEventListener(&quot;input&quot;, function() &#123; if (optionXCenter.checked) &#123; option.xCenter = true; &#125; else &#123; option.xCenter = false; option.x = parseInt(optionX.value); &#125; draw(option);&#125;);optionXCenter.addEventListener(&quot;change&quot;, function() &#123; if (optionXCenter.checked) &#123; option.xCenter = true; &#125; else &#123; option.xCenter = false; option.x = parseInt(optionX.value); &#125; draw(option);&#125;);//纵坐标var optionY = document.getElementById(&quot;text-option-y&quot;);optionY.value = option.y;var optionYCenter = document.getElementById(&quot;is-center-y&quot;);optionY.addEventListener(&quot;input&quot;, function() &#123; if (optionYCenter.checked) &#123; option.yCenter = true; &#125; else &#123; option.yCenter = false; option.y = parseInt(optionY.value); &#125; draw(option);&#125;);//是否垂直居中显示optionYCenter.addEventListener(&quot;change&quot;, function() &#123; if (optionYCenter.checked) &#123; option.yCenter = true; &#125; else &#123; option.yCenter = false; option.y = parseInt(optionY.value); &#125; draw(option);&#125;); 更改字体颜色大小123456789101112//字体颜色var textColor = document.getElementById(&quot;text-color&quot;);textColor.addEventListener(&quot;blur&quot;, function() &#123; textColor.value === &quot;&quot; ? option.color = &quot;#fff&quot; : option.color = &apos;#&apos; + textColor.value; draw(option);&#125;);//字体大小var textSize = document.getElementById(&quot;text-size&quot;);textSize.addEventListener(&quot;input&quot;, function() &#123; textSize.value === &quot;&quot; ? option.fontSize = &apos;20px Microsoft YaHei&apos; : option.fontSize = textSize.value + &apos;px Microsoft YaHei&apos;; draw(option);&#125;); 预览图片就是预览当前canvas的一个效果，这个就很简单了，就是新开一个窗口，然后把图片写进去 1234567891011121314151617//预览图片function saveImageInfo() &#123; var mycanvas = document.getElementById(&quot;thecanvas&quot;); //生成图片 var image = mycanvas.toDataURL(&quot;image/png&quot;); console.log(&apos;save&apos;) var w = window.open(&apos;about:blank&apos;, &apos;image from canvas&apos;); //把图片新进新的窗口 w.document.write(&quot;&lt;img src=&apos;&quot; + image + &quot;&apos; alt=&apos;from canvas&apos;/&gt;&quot;);&#125;var saveButton = document.getElementById(&quot;save-image&quot;);saveButton.addEventListener(&apos;click&apos;, saveImageInfo);//图片类型var imgType = document.getElementById(&quot;img-type&quot;);imgType.addEventListener(&quot;change&quot;, function() &#123; option.imgType = this.value;&#125;); 下载图片123456789101112131415161718192021222324//下载图片var downButton = document.getElementById(&quot;download-img&quot;);downButton.addEventListener(&apos;click&apos;, downloadImg);function downloadImg(fileName) &#123; //获取canvas var myCanvas = document.getElementById(&quot;thecanvas&quot;); //设置图片类型 var image = myCanvas.toDataURL(&quot;image/&quot; + option.imgType).replace(&quot;image/&quot; + option.imgType, &quot;image/octet-stream&quot;); var save_link = document.createElementNS(&apos;http://www.w3.org/1999/xhtml&apos;, &apos;a&apos;); save_link.href = image; //设置下载图片的名称 if(!option.all) &#123; fileName = &apos;&apos; save_link.download = option.text + &apos;.&apos; + option.imgType; &#125; else if(fileName == &apos;&apos;)&#123; save_link.download = &apos;canvas&apos; + &apos;.&apos; + option.imgType; &#125; else &#123; save_link.download = fileName + &apos;.&apos; + option.imgType; &#125; //下载图片 var event = document.createEvent(&apos;MouseEvents&apos;); event.initMouseEvent(&apos;click&apos;, true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null); save_link.dispatchEvent(event);&#125; 批量导出 首先批量导出，那么用户名我这里是使用空格分割，那么现在我在option里面，弄一个字段textAll，所有文字的集合。all代表是否是批量下载。fn属性代表回调函数 123456789//批量导出var downloadAll = document.getElementById(&quot;download-all&quot;);downloadAll.addEventListener(&apos;click&apos;, function() &#123; var _text = userName.value.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;).split(/\\s+/); option.textAll = _text; option.all = true; option.fn = downloadImg; draw(option);&#125;); 这时候就要判断是否要全部绘制的情况,所以要修改绘制函数的draw 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//画图function draw(obj) &#123; var canvas = document.getElementById(&quot;thecanvas&quot;); //画布大小 canvas.width = obj.width; canvas.height = obj.height; //设置图片 var img = new Image(); img.src = obj.img; img.width = canvas.width; img.height = canvas.height; var ctx = canvas.getContext(&quot;2d&quot;); //设置字体的坐标 var _x = obj.x, _y = obj.y; //是否居中显示 if (obj.xCenter) &#123; _x = obj.width / 2; &#125; if (obj.yCenter) &#123; _y = obj.height / 2; &#125; //图片加载后 img.onload = function () &#123; //是否是全部打印 if(obj.all)&#123; //遍历textAll for(var i=0;i&lt;obj.textAll.length;i++)&#123; //绘制图片 if(option.fill) &#123; ctx.drawImage(img,0, 0, option.width, option.height); &#125; else &#123; ctx.drawImage(img,0,0); &#125; //设置字体大小 ctx.font=obj.fontSize; //设置字体颜色 ctx.fillStyle=obj.color; //是否居中显示 if(obj.xCenter)&#123; ctx.textAlign=&quot;center&quot;; &#125; //绘制文字 ctx.fillText(obj.textAll[i], _x,_y); //是否回调 if(obj.fn)&#123; obj.fn(obj.textAll[i]); &#125; &#125; //最后取消全部批量下载 obj.all=false; &#125; else&#123; if(option.fill) &#123; ctx.drawImage(img,0, 0, option.width, option.height); &#125; else &#123; ctx.drawImage(img,0, 0); &#125; ctx.font=obj.fontSize; ctx.fillStyle=obj.color; if(obj.xCenter)&#123; ctx.textAlign=&quot;center&quot;; &#125; ctx.fillText(obj.text, _x,_y); &#125; &#125;;&#125;","tags":[{"name":"canvas","slug":"canvas","permalink":"https://ai-ruby.github.io/tags/canvas/"}]},{"title":"puppeteer 爬虫入门","date":"2018-07-27T06:51:12.150Z","path":"/posts/学习 puppeteer 入门/","text":"学习 puppeteer 简单模拟github登录页 puppeteerPuppeteer是谷歌官方出品的一个通过DevTools协议控制headless Chrome的Node库。可以通过Puppeteer的提供的api直接控制Chrome模拟大部分用户操作来进行UI Test或者作为爬虫访问页面来收集数据。 它可以做什么? 生成网页截图 或者 打印PDF 高级爬虫, 可以爬取大量异步渲染内容的网页 模拟键盘输入/表单自动提交/登录网页, 实现UI自动化测试 捕获站点的时间线,追踪网站,分析网站性能问题 安装环境Puppeteer本身依赖6.4以上的Node，但是为了异步超级好用的async/await，推荐使用7.6版本以上的Node。另外headless Chrome本身对服务器依赖的库的版本要求比较高，centos服务器依赖偏稳定，v6很难使用headless Chrome，提升依赖版本可能出现各种服务器问题（包括且不限于无法使用ssh），最好使用高版本服务器。 Node 7.6+ 初始化环境 mkdir demo – 新建目录 cd demo – 进入 demo 目录 npm init – 初始化NPM,填入必要的信息(一直按确定即可) npm i – save puppeteer – npm i == npm install , puppeteer 安装 基本用法 puppeteer.launch() 创建一个浏览器实例Browser对象 const page = await browser.newPage 通过browser对象创建页面 Page对象 page.goto() 跳转指定页面 page.screenshot() 对页面截图 page.pdf 生成pdf,可以打印下来 举个栗子 简单快速了解 puppeter 123456789101112131415161718192021222324252627282930const puppeteer = require(&apos;puppeteer&apos;)async function run () &#123; const browser = await puppeteer.launch() const page = await browser.newPage() // 新建一个浏览器页面 await page.goto(&apos;https://github.com&apos;) // 输入要爬虫的网址 await page.waitFor(1000) // 等待1000 // 截图保存到screenhots/目录下 await page.screenshot(&#123;path: &apos;screenshots/github.png&apos;&#125;) // 打印 pdf 操作 await page.pdf(&#123;path: &apos;example.pdf&apos;, format: &apos;A4&apos;&#125;) await page.waitForSeletor(&apos;.more&apos;) // 查找页面的元素 await page.click(&apos;.more&apos;) // 默认点击后 获得数据 // 提取元素内容方法 `evaluate` const result = await page.evaluate(() =&gt; &#123; const $ = window.$ console.log($) // 查看是否有引入jq, 为了更好查找你想要爬虫的元素数据 &#125;) browser.close() // 浏览器关闭 process.sennd(&#123;reult&#125;&#125; // 发送结果 process.close() // 程序关闭&#125; 注意: puppeteer 运用Chromium in 无界面模式, 模拟browser打开浏览器,然后模拟你操作或者操作后得到的数据,获取数据后browser很快关闭 动态模拟登陆 demo 新建一个 creds.js 123456// 注意: &apos;&apos;为自己的用户名和密码module.expors = &#123; username: &apos;&lt;GITHUB_USERNAME&gt;&apos; password: &apos;&lt;GITHUB_PASSWORD&gt;&apos;&#125; 新建 index.js 在调用 Puppeteer 的 launch 方法的时候传入参数对象中带有 headless: false，即可启动其 GUI 界面，进行可视化调试。 常用方法：点击可以使用page.click(selector[, options])方法，也可以选择聚焦page.focus(selector)。输入可以使用page.type(selector, text[, options])输入指定的字符串，还可以在options中设置delay缓慢输入更像真人一些。也可以使用keyboard.down(key[, options])来一个字符一个字符的输入。 123456789101112131415161718192021222324252627282930const puppeteer = require(&apos;puppeteer&apos;)const creds = reuqire(&apos;./creds&apos;) // 引入creds.js// 可立马执行;(async () =&gt; &#123; const browser = await puppeteer.launch(&#123; headless: false &#125;) const page = await.browser.newPage() await page.goto(&apos;https://github.com/login&apos;) // 找到对应 输入用户名,密码,提交按钮 const USERNAME_SELECTOR = #user_login&apos; const PASSWORD_SELECTOR = &apos;#user_password&apos; const BUTTON_SELECTOR = &apos;#signup_button&apos; await page.click(USERNAME_SELECTOR); await page.type(CREDS.username); await page.click(PASSWORD_SELECTOR); await page.type(CREDS.password); await page.click(BUTTON_SELECTOR); await page.waitForNavigation(); browser.close() // 浏览器关闭 &#125;)() 快速了解使用 API 1.模拟页面点击 123456page.mouseMoved(x, y, options = &#123;&#125;)page.mousePressed(x, y, options = &#123;&#125;)page.mouseReleased(x, y, options = &#123;&#125;)page.tap(x, y, options = &#123;&#125;)page.touchmove()page.touchend() 2.上下翻动页面 page.evaluate 的 window.scrollBy 1page.evaluate(_ =&gt; &#123; window.scrollBy(0, window.innerHeight); 3.获取element中的自定义属性 page.evaluate 的 object.getAttribute 123await page.evaluate( (obj) =&gt; &#123; return obj.getAttribute(&apos;data-src&apos;);&#125;, imgurlEle); 4.如何输入内容 page.type 12await page.click(&apos;#user_name&apos;)page.type(&apos;name&apos;) * page.evalute 后 element.value 12345await page.evaluate((a, b) =&gt; &#123; document.querySelector(&apos;#a&apos;).value = a; document.querySelector(&apos;#b&apos;).value = b; document.querySelector(&apos;#c&apos;).click(); &#125;, a, b); 5.获取页面html代码 page.content() 6.关闭弹窗 dialong.accept 123page.on(&apos;dialog&apos;, dialog =&gt; &#123; dialog.accept(&apos;test&apos;)&#125;) 7.读取和设置 cookies page.setCookies 和 page.cookies 接口 8.上传文件 elementHandle.uploadFile(…filePaths)接口, 目前只支持 input type=”file”类型的文件提交 9.监控页面的网络请求 1234567891011const page = await browser.newPage();await page.setRequestInterceptionEnabled(true);page.on(&apos;request&apos;, request =&gt; &#123; request.continue(); // pass it through.&#125;);page.on(&apos;response&apos;, response =&gt; &#123; const req = response.request(); console.log(req.method, response.status, req.url);&#125;); 10.如何在页面中不同的Frame中切换 通过page.frames()获得frame的数组，使用 iframe.$ 来获得对应frame中的handle 123456789101112const browser = await puppeteer.launch(&#123;headless: false&#125;);const page = await browser.newPage();await page.setContent(&apos;&lt;iframe&gt;&lt;/iframe&gt;&apos;);// the page.frames()[0] is always a main frame.const iframe = page.frames()[1];// fetch the body element of the iframeconst body = await iframe.$(&apos;body&apos;);// ...// do something with `body`..// ...browser.close(); 11.page.evalute 能否返回page DOM? 可以传入 ObjectHandle到page.evaluate中成为DOM元素，但当DOM被返回的时候则成 为对应的ObjectHandle. 如果需要返回，也可以返回实际需要的值 1234const list = await page.evaluateHandle(() =&gt; &#123;return Array.from(document.getElementsByTagName(&apos;a&apos;)).map(a =&gt; a.href);&#125;);console.log(await list.jsonValue()); 12.避免页面ssl认证错误信息 通过puppeteer option ignoredHTTPErrors 实现","tags":[{"name":"puppeteer","slug":"puppeteer","permalink":"https://ai-ruby.github.io/tags/puppeteer/"}]},{"title":"Learning Typescript","date":"2018-07-27T03:31:04.000Z","path":"/posts/学习typescript/","text":"学习typescript 数据类型 | 相关函数 | 类 | 接口 安装环境 node 环境 去官网下载个新版本 https://nodejs.org/zh-cn/ 安装node的同时 npm也会安装起来的 输入node -v , npm-v后可看到版本号即安装成功 全局安装Typescript, -g是全局 npm install typescript -g tsc -v 注意如果是mac系统,则需要sudo 简单编写hello world 1.初始化项目:进入你的编程文件夹后使用npm init -y初始化,生成 package.json 文件配置 2.typescript项目配置文件: 创建 tsconfig.json文件,命令行输入 tsc --init,此文件可以通过读取它来设置Typescript编译器参数 3.安装@types/node: 使用 npm install @type/node --dev-save进行安装.主要是解决模块的声明文件问题 4.新建HelloWorld.ts文件,然后保存,代码如下 12var a:string = &quot;HelloWorld&quot;console.log(a) 5自动编译: 若是在vscode编程的,在其任务菜单下,运行生成任务, 然后选择tsc: 构建-tsconfig.json,这时候会生成一个 HelloWorld.js,选择tsc: 监视-tsconfig.json,则时刻监控.ts文件 若是HBuilder: 最上方菜单栏点击工具-插件安装 点击下方浏览Eclipse插件市场 搜索 typescript插件进行安装后重启编辑器 点击菜单栏工具-选项,选择编译ts文件Typescript-Compiler - 勾选 Compiler all Typescript files on build 在项目上右键点击-配置 Enalbe typescript builder,之后再保存.ts文件时会自动在当前目录编译对应的目录 不是自动编译的则在命令行输入 tsc 文件名,即可 typescript中的数据类型 typescript为了是编写代码更规范,更有利维护,增加类型的验证,提供以下的数据类型 boolean 布尔类型 number 数字类型 string 字符串类型 array 数字类型 tuple 元组类型 enum 枚举类型 any 任意类型 null和undefined voild 类型 never 其他类型 注意: ts代码必须指定类型 boolean 布尔类型123456789// es5: 正确写法,但是在ts是错误写法var flag = false;flag = 456// ts写法:var flag:boolean = falseflag = true // 正确// flag = 123 // 错误console.log(flag) number和string类型和boolean类型定义一样array数组类型, ts有三种方式 1.arr:number[] = [] 指定arr数组里都是数字,如果有字符串或者其他类型会报错,即使运行成功,但是ts规则也会报错的 12345var arr1:number[]=[11, 22, 33] var arr2:number[]=[11, 22, &apos;33&apos;] // ts规则报错console.log(arr1) 2.arr:Array&lt;number&gt;= [] 123var arr3:Array&lt;number&gt;= [11, 22, 33]console.log(arr3) arr:any[] = [] 12var arr4:any[] = [&apos;12&apos;, 23, true]console.log(arr4) tuple 元组类型 属于数组一种, 可以数组或者是字符串,指定数组每一个位置中指定特定类型 123let arr:[number, string] = [123, &apos;this is ts&apos;] // 正确// let arr:[number, string] = [&apos;123&apos;, &apos;this is ts&apos;] // 错误 enum 枚举类型 事先考虑到某一个变量可能取到的值,尽量用自然语言中含义清楚的单词来表示它的每一个值 –就叫枚举方法,用这个方法定义的类型称枚举类型 1234enum Flag &#123;success=1, error=2&#125;let s:Flag = Flag.successconsole.log(s) // 1 如果标识符没有赋值,则它的值就是下标 123456789101112enum Color &#123;blue, red, &apos;orange&apos;&#125;var c:Color = Color.redconsole.log(c) // 1// 若red = 3enum Color &#123;blue, red = 3, &apos;orange&apos;&#125;var o:Color = Color.orangeconsole.log(o) // 4 any 任意类型 可以定义任意类型,number,string,boolean都行 任意类型的用处 123const oBox:any = document.getElementById(&apos;box&apos;)oBox.style.color = &apos;red&apos; null和undefined 其他(never))类型的子类型1234567891011// var num:number // 输出会报错var num:undefined // 输出undefined 不会报错console.log(num) // undefined// 定义未赋值var num: number | undefined// 一个元素可能是number类型,可能是 null, undefined类型var num:number | null | undefined void类型 没有任何类型,一般用于定义方法的时候没有返回值 123456789101112131415161718192021// 正确写法// 没有返回值function run1():void &#123; console.log(&apos;run&apos;)&#125;run1()// 有返回值,返回值是什么类型的则定义什么类型function run2():number &#123; return 123&#125;run2()// 错误写法function run3():undefined &#123; console.log(&apos;run&apos;)&#125;run3() never类型: 其他类型 包括(null 和 undefined)的子类型,代表从不会出现的值 这意味着声明 never的变量只能被never类型赋值 1234567var a:never// a = 123 // 报错a(() =&gt; &#123; throw new Error(&apos;error&apos;)&#125;) typescript 函数 函数的定义 可选参数 默认参数 剩余参数 函数重载 箭头函数 es6 函数的定义es5:12345// 函数声明function run() &#123;&#125;// 匿名函数var run2 = function() &#123;&#125; ts:12345678910111213// 函数声明function run:string &#123; return &apos;run&apos; // return 123 // 错误,定义未string类型&#125;// 匿名函数var run = function():number &#123; return 123&#125;run() ts中定义方法传参 12345678910111213// 函数声明function getInfo(name:string, age:number):string &#123; return `$&#123;name&#125; -- $&#123;age&#125;`&#125;console.log(getInfo(&apos;xiao&apos;, 20))// 匿名函数var getInfo2 = function(name:string, age:number):string &#123; return `$&#123;name&#125; -- $&#123;age&#125;`&#125;console.log(getInfo2(&apos;xiao2&apos;, 22)) 方法可选参数 es5里面的方法的实参和形参可以不一样,但ts中必须一样,如果不一样就需要配置可选参数 ? 配置参数,注意可选参数必须配置到参数后面 形参中有个?则是可传可不传,没有的,则一定传123456789101112131415function getInfo(name:string, age?:number):string &#123; if(age) &#123; return `$&#123;name&#125; -- $&#123;age&#125;` &#125; else &#123; return `$&#123;name&#125; -- 年龄保密` &#125;&#125;console.log(getInfo(&apos;xiao&apos;)) // xiao -- 年龄保密console.log(getInfo(&apos;xiao&apos;, 12)) // xiao -- 12// 错误写法 可选参数必须配置到参数后面// function getInfo(name?:string, age:number):string &#123;&#125; 默认参数 es5 没法设置默认参数,但是es6和ts可以设置默认参数 123456789function getInfo(name:string, age:number=20):string &#123; if(age) &#123; return `$&#123;name&#125; -- $&#123;age&#125;` &#125; else &#123; return `$&#123;name&#125; -- 年龄保密` &#125;&#125;console.log(getInfo(&apos;xiao&apos;)) 剩余参数12345678910111213141516171819function sum(a:number, b:number, c:number):number &#123; return a+b+c&#125;console.log(sum(1,2,3))// 三点运算符function sum(...result:number[]):number &#123; var sum = 0 for(var i =0; i &lt; result.length; i++) &#123; sum += result[i] &#125; return sum&#125;console.log(sum(1,2,3)) 函数重载 java中方法的重载,重载是指两个或者两个以上同名函数,但它们的参数不一样,这时会出现函数重载情况 typescript中的重载,通过为同一个函数提供多个函数类型定义来试下多种功能的目的 1234567891011121314151617181920// es5中出现同名方法会替换上面的方法function css(config) &#123;&#125;function css(config, value) &#123;&#125;// ts中的重载function getInfo(name:string):string;function getInfo(age:number):number;function getInfo(str:any):any &#123; if(str === &apos;string&apos;) &#123; return &apos;我的名字叫&apos; + str &#125; else &#123; return &apos;我的年龄是&apos; + str &#125;&#125;console.log(getInfo(&apos;xiao&apos;)) // 正确console.log(getInfo(20)) // 正确// console.log(getInfo(true)) // 错误,因为上面并没有找到参数和boolean类型匹配的 箭头函数123setTimeout(() =&gt; &#123; console.log(&apos;run&apos;)&#125;, 1000) typescript 类 类的定义 继承 类的修饰符 静态属性 静态方法 抽象类 继承 多态 类的定义123456789101112131415161718192021222324252627// es5function Person(name) &#123; this.name = name this.run = function() &#123; console.log(this.name) &#125;&#125;var p = new Person(&apos;xiao&apos;)p.run()// tsclass Person &#123; name: string // 属性 前面忽略public关键词 constructor(n:string) &#123; // 构造函数 实例化类的时候触发方法 this.name = n &#125; run():void &#123; console.log(this.name) &#125;&#125;var p = new Person(&apos;xiao&apos;)p.run() get和set 123456789101112131415161718192021222324class Person &#123; name: string // 属性 前面忽略public关键词 constructor(name:string) &#123; // 构造函数 实例化类的时候触发方法 this.name = name &#125; getName(name:string):string &#123; return this.name &#125; setNmae(name:string):void &#123; this.name = name &#125;&#125;var p = new Person(&apos;xiao1&apos;)console.log(p.getName()) // xiao1p.setName(&apos;xiao ming&apos;)console.log(p.getName()) // xiao mingvar p = new Person(&apos;xiao&apos;)p.run() ts中实现继承 extends\\ super123456789101112131415161718192021222324class Person &#123; name: string constructor(name:string) &#123; this.name = name &#125; run():string &#123; return this.name &#125;&#125;var p = new Person(&apos;xiao&apos;)console.log(r.run()) class Web extends Person &#123; constructor(name:string) &#123; super(name) &#125;&#125;var w = new Web(&apos;super&apos;)console.log(w.run()) 类的修饰符 名称 类型 说明 public 公有 在当前类里面 子类 类外面都可以访问 protected 保护类型 在当前类里面 子类可以访问, 类外部无法访问 priviate 私有 在当前类里面可以访问, 子类,类外部无法访问 属性如果不写修饰符,则是公有 12345678910111213 class Person &#123; public name: string // 公有 // protected name: string // 保护 // priviate name: string // 私有 constructor(name:string) &#123; this.name = name &#125; run():string &#123; return this.name &#125;&#125; 静态属性 静态属性和静态方法在其定义前加 static 静态方法 里面没法直接调用类里面的属性 es5 1234567891011// 实例化方法function Person () &#123; this.run1 = function() &#123;&#125;&#125; // 静态方法Person.name = &apos;哈哈&apos;Person.run2 = function() &#123;&#125;var p = new Person() Person.run() // 静态方法的调用 ts 1234567891011121314151617181920212223242526class Person&#123; public name:string static sex = &apos;man&apos; // 静态属性 constructor(name:string) &#123; this.name = name &#125; run() &#123; console.log(`$&#123;this.name&#125;在运动`) &#125; work() &#123; console.log(`$&#123;this.name&#125;在工作`) &#125; // 静态方法 里面没法直接调用类里面的属性 static print() &#123; console.log(&apos;static&apos; + Person.sex) &#125;&#125;Person.print()console.log(Person.sex) 多态 父类定义一个方法不去实现,让继承它的子类去实现, 每个子类有不同的表现 属于继承 12345678910111213141516171819202122232425262728293031class Animal &#123; name:string constructor(name:string) &#123; this.name = name &#125; eat() &#123; console.log(&apos;eat ---- &apos;) &#125;&#125;class Dog extends Animal &#123; constructor (name: string) &#123; super(name) &#125; eat() &#123; return this.name + &apos;吃东西&apos; &#125;&#125;class Cat extends Animal &#123; constructor (name: string) &#123; super(name) &#125; eat() &#123; return this.name + &apos;吃猫粮&apos; &#125;&#125; 抽象类 它是提供其他继承的基类,不能直接被实例化 用abstract关键字定义抽象类和抽象方法,抽象类中的抽象方法不包含具体实现并且必须在派生类中实现 abstract 抽象方法只能放在抽象类里面 抽象类和抽象方法用来定义标准 123456789101112131415161718192021222324252627282930// 标准: Animal 这个类要求它的子类必须包含 eat 方法abstract class Animal &#123; name:string constructor(name:string) &#123; this.name = name &#125; // 其他抽象类子类必须实现此方法 abstract eat():any &#123; console.log(&apos;eat ---- &apos;) &#125; // 其他方法可以不用实现 run() &#123;&#125;&#125;// var a = new Animal() // 错误写法class Dog extends Animal &#123; constructor (name: any) &#123; super(name) &#125; eat() &#123; console.log(`$&#123;this.name&#125;吃狗粮`) &#125;&#125;const dog = new Animal(&apos;dog&apos;)d.eat() typescript 接口 属性类接口 函数类型接口 可索引接口 类类型接口 接口扩展 属性接口 自定义方法传入参数,对json的约束 1234567function printLabel(&#123;labelInfo: &#123;label:string&#125;&#125;):void &#123; console.log(&apos;printLabel&apos;)&#125;// printLabel(&apos;hhh&apos;) // 错误写法// printLabel(&#123;name: &apos;xiao&apos;&#125;) // 错误写法printLabel(&#123;label: &apos;xiao ming&apos;&#125;) // 正确 对批量方法传入参数进行约束, 必须有关键字interface 12345678910111213141516171819202122232425262728interface FullName &#123; firstName: string; // 注意: 一定是 `;`结束 secondName: string;&#125;function printName(name: FullName) &#123; console.log(`$&#123;name.firstName&#125;----$&#123;name.secondName&#125; )&#125;function printInfo(info: FullName) &#123; console.log(`$&#123;info.firstName&#125;----$&#123;info.secondName&#125; )&#125;var obj = &#123; age: 20, firstName : &apos;xiao&apos;, secondName: &apos;ming&apos;&#125;var info = &#123; firstName : &apos;xiao&apos;, secondName: &apos;ming&apos;&#125;printName(obj)printInfo(info) 函数类型接口 对方法传入的参数以及返回值进行约束 123456789interface encrypt &#123; (key:string, value:string):string&#125;var md5:encrypt = function(key:string, value:string):string &#123; return key+value&#125;console.log(md5(&apos;name&apos;, &apos;xiao&apos;)) 可索引接口 对数组对象约束,不常用 12345678910111213141516171819202122// ts 定义数组方式var arr:number[] = [12, 23]var arr1:Array&lt;string&gt;=[&apos;12&apos;, &apos;23&apos;]// 对数组约束interface UserArr &#123; [index: number]:string&#125;var arr2:UserArr = [&apos;aaa&apos;, &apos;bbb&apos;]console.log(arr2[0])// 对对象约束interface UserObj &#123; [index:string]:string&#125;var arr3:UserObj = [name: &apos;xiao ming&apos;]console.log(arr3) 类类型接口 对类的约束和抽象类有点相似 1234567891011121314151617181920interface Animal &#123; name: string eat(str: string): void&#125;class Dog implements Animal &#123; name: string constructor(name: string) &#123; this.name = name &#125; eat() &#123; console.log(this.name + &apos;吃狗粮&apos;) &#125;&#125;var d = new Dog(&apos;dog&apos;)d.eat() 接口扩展 接口可以继承接口 1234567891011121314151617181920212223242526interface Animal &#123; eat(): void&#125;interface Person extends Animal &#123; word(): void&#125;class Web implements Person &#123; public name:string constructor(name:string) &#123; this.name = name &#125; eat() &#123; console.log(this.name + &apos;吃中餐&apos;) &#125; work() &#123; console.log(this.name + &apos;工作&apos;) &#125;&#125;var w = new Web(&apos;xiao ku&apos;)w.eat() 1234567891011121314151617181920212223242526272829303132333435interface Animal &#123; eat(): void&#125;interface Person extends Animal &#123; work(): void&#125;class Programmer &#123; public name: string constructor(name: string) &#123; this.name = name &#125; coding(code: string) &#123; console.log(this.name + code) &#125;&#125;class Web extends Programmer implements Person &#123; constructor(name: string) &#123; super(name) &#125; eat() &#123; console.log(this.name + &apos;喜欢吃馒头&apos;) &#125; work() &#123; console.log(this.name + &apos;写代码&apos;) &#125;&#125;var w = new Web(&apos;小李&apos;)// w.eat()w.coding(&apos;敲代码&apos;) typescript 泛型 泛型的定义 泛型函数 泛型类 泛型接口 泛型定义 泛型:软件工程中,不仅要创建一致定义良好的API, 组件不仅能够支持当前的数据类型,同事也能支持未来的数据类型,这在创建大型系统时为你提供十分灵活的功能 就是解决类接口,方法的复用性,以及对不特定数据类型的支持(类型校验) 可以支持不特定的数据类型, 但传入的参数和返回的参数一致 T表示泛型,具体什么类型是调用这个方法的时候决定的 泛型函数123456789101112131415function getData&lt;T&gt;(value:T):T &#123; return value&#125;getDate&lt;number&gt;(123) // 正确getDate&lt;number&gt;(&apos;123&apos;) // 错误// any 返回指定值不报错,通常推荐以上写法function getData&lt;T&gt;(value:T):any &#123; return value&#125;getDate&lt;number&gt;(123)getDate&lt;string&gt;(&apos;123&apos;) 泛型类 比如有个最小堆算法,需要同时支持返回数字和字符串两种类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class MinClass &#123; public list: number[] = [] add(num: number) &#123; this.list.push(num) &#125; min() &#123; var minNum = this.list[0] for (var i = 0; i &lt; this.list.length; i++) &#123; if (minNum &gt; this.list[i]) &#123; minNum = this.list[i] &#125; &#125; return minNum &#125;&#125;var m = new MinClass()m.add(289)m.add(22)m.add(23)m.add(28)console.log(m.min())// ts写法class MinClass&lt;T&gt; &#123; public list: T[] = [] add(value:T):void &#123; this.list.push(value) &#125; min():T &#123; var minNum = this.list[0] for (var i = 0; i &lt; this.list.length; i++) &#123; if (minNum &gt; this.list[i]) &#123; minNum = this.list[i] &#125; &#125; return minNum &#125;&#125;var m1 = new MinClass&lt;number&gt;() // 实例化类, 并且指定了类的T代表类型是numberm1.add(29)m1.add(22)console.log(m1.min())``` #### 泛型接口函数类型接口写法 interface ConfigFn { (value1:string, value2 :string):string} var setData:configFn = function(value1:string,value2:string) { return value1+value2} setData(‘name’, ‘xiao ming’) 1.泛型接口写法interface ConfigFn { (value:T):T} var getData1:ConfigFn = function(value:T):T { return value} getData1(‘xiao xiao’)122.泛型接口写法 interface ConfigFn { (value:T):T} function getData3(value:T):T { return value} var myGetData:ConfigFn = getData3myGetData(‘xiao hong’)`","tags":[{"name":"typescript","slug":"typescript","permalink":"https://ai-ruby.github.io/tags/typescript/"}]},{"title":"Mac 使用Hexo + github 搭建个人博客详解","date":"2018-04-03T03:32:40.614Z","path":"/posts/Hexo + github 搭建个人博客/","text":"在Mac平台通过Hexo + github 搭建个人博客 Hexo 安装流程环境配置 node.js 官网 git 官网 具体怎么安装就不细说了,在准备环境搭建好之后,就可以开始使用Hexo搭建博客了 安装Hexo 当Node.js和git都安装好了,就可以安装 Hexo, 在终端执行以下命令 1npm install -g hexo-cli/Users/ruai/projects/blogs/hexo-blogs/source/_posts/Typescript.md Hexo初始化 在自己项目目录下新建一个文件夹 123hexo initnpm install ==&gt; 简写 npm ihexo server ==&gt; 简写 hexo s 此时在浏览器中打开网址http://localhost:4000 就可以看到一个静态网页 Hexo文件夹目录结构 source：博客资源文件夹 source/_drafts：草稿文件夹 source/_posts：文章文件夹 themes：存放主题的文件夹 themes/landscape：默认的主题 _config.yml：全局配置文件 部署到Github Pages 创建github账号并创建repository 博客发布到Github Pages上，供外网访问，当然你也可以部署到其他服务器上，Github Pages服务的使用步骤： 开通Github账号，例如我的账号名CSDNHensen，这个后面会用到 创建一个repository，名称开头必须和账号名一样，然后以.github.io结尾 修改hexo的配置文件 修改配置文件：_config.yml，整个站点的配置都在这里，打开_config.yml文件 找到下面的语句，然后修改你的信息，repository在github仓库中可以复制 github或者是coding 也行, 我是使用github的 123456deploy: type: git repository: github: https://github.com/github名/github名.github.io coding: https://git.coding.net/coding/coding.coding.me.git branch: master 注意项: 注意：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错.* 修改Hexo主题 下载喜欢的主题 可到 Hexo官网themes 选择喜欢的主题 本主题是 tomotoes 在项目执行以下命令1git clone https://github.com/Tomotoes/hexo-theme-tomotoes themes/tomotoes 在配置文件下修改themes 在项目_config.yml 找到 themes修改为tomotoes 可查看主题文档安装,以下不细说 建立博客新建博客 发布博客有两种方式: 一:通过命令行生成博客样板; 二:直接用markdown文档写完后放置/source/_posts目录下 1hexo new HelloWord 新生成的文章都会保存在/source/_posts目录下，打开生成的模板，内容如下 1234---title: Mac 使用Hexo + github 搭建个人博客详解abbrlink: 16107--- 生成博客 新增了博客文章后，需要提交到服务器上，输入以下指令完成将博客生成静态Html文件 1hexo generate hexo generate 简写 hexo g 发布博客到服务器 安装hexo-deployer-git工具，输入指令如果是第一次发布的需要安装hexo-deployer-git工具 1npm install hexo-deployer-git --save 提交到服务器上，提交过程中还需要输入github账号和密码 1hexo deploy hexo deploy 简写 hexo d 终端cd到blog目录下执行如下命令(每次部署文章的步骤)： 123hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g // 生成缓存和静态文件hexo d // 重新部署到服务器 Hexo快捷命令Hexo常用命令12345hexo new &quot;postName&quot; //新建文章hexo new page &quot;pageName&quot; //新建页面hexo generate //生成静态页面至public目录hexo server //开启预览访问端口（默认端口4000，ctrl+c关闭server）hexo deploy //将.deploy目录部署到服务器 简写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 快捷简写 12hexo d -g == hexo deploy -generatehexo g -d == hexo -deploy -deploy","tags":[{"name":"hexo","slug":"hexo","permalink":"https://ai-ruby.github.io/tags/hexo/"}]}]