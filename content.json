{"meta":{"title":"Hexo","subtitle":null,"description":"Run to full stack engineer.","author":"ai-ruby","url":"https://ai-ruby.github.io"},"pages":[{"title":"","date":"2018-05-10T09:24:16.312Z","updated":"2018-05-10T09:23:33.845Z","comments":true,"path":"baidu_verify_q9v7ZCgLii.html","permalink":"https://ai-ruby.github.io/baidu_verify_q9v7ZCgLii.html","excerpt":"","text":"q9v7ZCgLii"},{"title":"about","date":"2018-04-03T03:51:58.000Z","updated":"2018-04-03T03:53:18.641Z","comments":true,"path":"about/index.html","permalink":"https://ai-ruby.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-04-03T03:51:47.000Z","updated":"2018-07-27T03:50:57.107Z","comments":false,"path":"categories/index.html","permalink":"https://ai-ruby.github.io/categories/index.html","excerpt":"","text":"学习笔记"},{"title":"tags","date":"2018-04-03T03:51:29.000Z","updated":"2018-04-03T03:52:25.518Z","comments":false,"path":"tags/index.html","permalink":"https://ai-ruby.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Learning Typescript","slug":"Typescript","date":"2018-07-27T03:31:04.000Z","updated":"2018-07-27T04:03:46.209Z","comments":true,"path":"2018/07/27/Typescript/","link":"","permalink":"https://ai-ruby.github.io/2018/07/27/Typescript/","excerpt":"","text":"学习typescript 数据类型 | 相关函数 | 类 | 接口 安装环境 node 环境 去官网下载个新版本 https://nodejs.org/zh-cn/ 安装node的同时 npm也会安装起来的 输入node -v , npm-v后可看到版本号即安装成功 全局安装Typescript, -g是全局 npm install typescript -g tsc -v 注意如果是mac系统,则需要sudo 简单编写hello world 1.初始化项目:进入你的编程文件夹后使用npm init -y初始化,生成 package.json 文件配置 2.typescript项目配置文件: 创建 tsconfig.json文件,命令行输入 tsc --init,此文件可以通过读取它来设置Typescript编译器参数 3.安装@types/node: 使用 npm install @type/node --dev-save进行安装.主要是解决模块的声明文件问题 4.新建HelloWorld.ts文件,然后保存,代码如下 12var a:string = &quot;HelloWorld&quot;console.log(a) 5自动编译: 若是在vscode编程的,在其任务菜单下,运行生成任务, 然后选择tsc: 构建-tsconfig.json,这时候会生成一个 HelloWorld.js,选择tsc: 监视-tsconfig.json,则时刻监控.ts文件 若是HBuilder: 最上方菜单栏点击工具-插件安装 点击下方浏览Eclipse插件市场 搜索 typescript插件进行安装后重启编辑器 点击菜单栏工具-选项,选择编译ts文件Typescript-Compiler - 勾选 Compiler all Typescript files on build 在项目上右键点击-配置 Enalbe typescript builder,之后再保存.ts文件时会自动在当前目录编译对应的目录 不是自动编译的则在命令行输入 tsc 文件名,即可 typescript中的数据类型 typescript为了是编写代码更规范,更有利维护,增加类型的验证,提供以下的数据类型 boolean 布尔类型 number 数字类型 string 字符串类型 array 数字类型 tuple 元组类型 enum 枚举类型 any 任意类型 null和undefined voild 类型 never 其他类型 注意: ts代码必须指定类型 boolean 布尔类型123456789// es5: 正确写法,但是在ts是错误写法var flag = false;flag = 456// ts写法:var flag:boolean = falseflag = true // 正确// flag = 123 // 错误console.log(flag) number和string类型和boolean类型定义一样array数组类型, ts有三种方式 1.arr:number[] = [] 指定arr数组里都是数字,如果有字符串或者其他类型会报错,即使运行成功,但是ts规则也会报错的 12345var arr1:number[]=[11, 22, 33] var arr2:number[]=[11, 22, &apos;33&apos;] // ts规则报错console.log(arr1) 2.arr:Array&lt;number&gt;= [] 123var arr3:Array&lt;number&gt;= [11, 22, 33]console.log(arr3) arr:any[] = [] 12var arr4:any[] = [&apos;12&apos;, 23, true]console.log(arr4) tuple 元组类型 属于数组一种, 可以数组或者是字符串,指定数组每一个位置中指定特定类型 123let arr:[number, string] = [123, &apos;this is ts&apos;] // 正确// let arr:[number, string] = [&apos;123&apos;, &apos;this is ts&apos;] // 错误 enum 枚举类型 事先考虑到某一个变量可能取到的值,尽量用自然语言中含义清楚的单词来表示它的每一个值 –就叫枚举方法,用这个方法定义的类型称枚举类型 1234enum Flag &#123;success=1, error=2&#125;let s:Flag = Flag.successconsole.log(s) // 1 如果标识符没有赋值,则它的值就是下标 123456789101112enum Color &#123;blue, red, &apos;orange&apos;&#125;var c:Color = Color.redconsole.log(c) // 1// 若red = 3enum Color &#123;blue, red = 3, &apos;orange&apos;&#125;var o:Color = Color.orangeconsole.log(o) // 4 any 任意类型 可以定义任意类型,number,string,boolean都行 任意类型的用处 123const oBox:any = document.getElementById(&apos;box&apos;)oBox.style.color = &apos;red&apos; null和undefined 其他(never))类型的子类型1234567891011// var num:number // 输出会报错var num:undefined // 输出undefined 不会报错console.log(num) // undefined// 定义未赋值var num: number | undefined// 一个元素可能是number类型,可能是 null, undefined类型var num:number | null | undefined void类型 没有任何类型,一般用于定义方法的时候没有返回值 123456789101112131415161718192021// 正确写法// 没有返回值function run1():void &#123; console.log(&apos;run&apos;)&#125;run1()// 有返回值,返回值是什么类型的则定义什么类型function run2():number &#123; return 123&#125;run2()// 错误写法function run3():undefined &#123; console.log(&apos;run&apos;)&#125;run3() never类型: 其他类型 包括(null 和 undefined)的子类型,代表从不会出现的值 这意味着声明 never的变量只能被never类型赋值 1234567var a:never// a = 123 // 报错a(() =&gt; &#123; throw new Error(&apos;error&apos;)&#125;) typescript 函数 函数的定义 可选参数 默认参数 剩余参数 函数重载 箭头函数 es6 函数的定义es5:12345// 函数声明function run() &#123;&#125;// 匿名函数var run2 = function() &#123;&#125; ts:12345678910111213// 函数声明function run:string &#123; return &apos;run&apos; // return 123 // 错误,定义未string类型&#125;// 匿名函数var run = function():number &#123; return 123&#125;run() ts中定义方法传参 12345678910111213// 函数声明function getInfo(name:string, age:number):string &#123; return `$&#123;name&#125; -- $&#123;age&#125;`&#125;console.log(getInfo(&apos;xiao&apos;, 20))// 匿名函数var getInfo2 = function(name:string, age:number):string &#123; return `$&#123;name&#125; -- $&#123;age&#125;`&#125;console.log(getInfo2(&apos;xiao2&apos;, 22)) 方法可选参数 es5里面的方法的实参和形参可以不一样,但ts中必须一样,如果不一样就需要配置可选参数 ? 配置参数,注意可选参数必须配置到参数后面 形参中有个?则是可传可不传,没有的,则一定传123456789101112131415function getInfo(name:string, age?:number):string &#123; if(age) &#123; return `$&#123;name&#125; -- $&#123;age&#125;` &#125; else &#123; return `$&#123;name&#125; -- 年龄保密` &#125;&#125;console.log(getInfo(&apos;xiao&apos;)) // xiao -- 年龄保密console.log(getInfo(&apos;xiao&apos;, 12)) // xiao -- 12// 错误写法 可选参数必须配置到参数后面// function getInfo(name?:string, age:number):string &#123;&#125; 默认参数 es5 没法设置默认参数,但是es6和ts可以设置默认参数 123456789function getInfo(name:string, age:number=20):string &#123; if(age) &#123; return `$&#123;name&#125; -- $&#123;age&#125;` &#125; else &#123; return `$&#123;name&#125; -- 年龄保密` &#125;&#125;console.log(getInfo(&apos;xiao&apos;)) 剩余参数12345678910111213141516171819function sum(a:number, b:number, c:number):number &#123; return a+b+c&#125;console.log(sum(1,2,3))// 三点运算符function sum(...result:number[]):number &#123; var sum = 0 for(var i =0; i &lt; result.length; i++) &#123; sum += result[i] &#125; return sum&#125;console.log(sum(1,2,3)) 函数重载 java中方法的重载,重载是指两个或者两个以上同名函数,但它们的参数不一样,这时会出现函数重载情况 typescript中的重载,通过为同一个函数提供多个函数类型定义来试下多种功能的目的 1234567891011121314151617181920// es5中出现同名方法会替换上面的方法function css(config) &#123;&#125;function css(config, value) &#123;&#125;// ts中的重载function getInfo(name:string):string;function getInfo(age:number):number;function getInfo(str:any):any &#123; if(str === &apos;string&apos;) &#123; return &apos;我的名字叫&apos; + str &#125; else &#123; return &apos;我的年龄是&apos; + str &#125;&#125;console.log(getInfo(&apos;xiao&apos;)) // 正确console.log(getInfo(20)) // 正确// console.log(getInfo(true)) // 错误,因为上面并没有找到参数和boolean类型匹配的 箭头函数123setTimeout(() =&gt; &#123; console.log(&apos;run&apos;)&#125;, 1000) typescript 类 类的定义 继承 类的修饰符 静态属性 静态方法 抽象类 继承 多态 类的定义123456789101112131415161718192021222324252627// es5function Person(name) &#123; this.name = name this.run = function() &#123; console.log(this.name) &#125;&#125;var p = new Person(&apos;xiao&apos;)p.run()// tsclass Person &#123; name: string // 属性 前面忽略public关键词 constructor(n:string) &#123; // 构造函数 实例化类的时候触发方法 this.name = n &#125; run():void &#123; console.log(this.name) &#125;&#125;var p = new Person(&apos;xiao&apos;)p.run() get和set 123456789101112131415161718192021222324class Person &#123; name: string // 属性 前面忽略public关键词 constructor(name:string) &#123; // 构造函数 实例化类的时候触发方法 this.name = name &#125; getName(name:string):string &#123; return this.name &#125; setNmae(name:string):void &#123; this.name = name &#125;&#125;var p = new Person(&apos;xiao1&apos;)console.log(p.getName()) // xiao1p.setName(&apos;xiao ming&apos;)console.log(p.getName()) // xiao mingvar p = new Person(&apos;xiao&apos;)p.run() ts中实现继承 extends\\ super123456789101112131415161718192021222324class Person &#123; name: string constructor(name:string) &#123; this.name = name &#125; run():string &#123; return this.name &#125;&#125;var p = new Person(&apos;xiao&apos;)console.log(r.run()) class Web extends Person &#123; constructor(name:string) &#123; super(name) &#125;&#125;var w = new Web(&apos;super&apos;)console.log(w.run()) 类的修饰符 名称 类型 说明 public 公有 在当前类里面 子类 类外面都可以访问 protected 保护类型 在当前类里面 子类可以访问, 类外部无法访问 priviate 私有 在当前类里面可以访问, 子类,类外部无法访问 属性如果不写修饰符,则是公有 12345678910111213 class Person &#123; public name: string // 公有 // protected name: string // 保护 // priviate name: string // 私有 constructor(name:string) &#123; this.name = name &#125; run():string &#123; return this.name &#125;&#125; 静态属性 静态属性和静态方法在其定义前加 static 静态方法 里面没法直接调用类里面的属性 es5 1234567891011// 实例化方法function Person () &#123; this.run1 = function() &#123;&#125;&#125; // 静态方法Person.name = &apos;哈哈&apos;Person.run2 = function() &#123;&#125;var p = new Person() Person.run() // 静态方法的调用 ts 1234567891011121314151617181920212223242526class Person&#123; public name:string static sex = &apos;man&apos; // 静态属性 constructor(name:string) &#123; this.name = name &#125; run() &#123; console.log(`$&#123;this.name&#125;在运动`) &#125; work() &#123; console.log(`$&#123;this.name&#125;在工作`) &#125; // 静态方法 里面没法直接调用类里面的属性 static print() &#123; console.log(&apos;static&apos; + Person.sex) &#125;&#125;Person.print()console.log(Person.sex) 多态 父类定义一个方法不去实现,让继承它的子类去实现, 每个子类有不同的表现 属于继承 12345678910111213141516171819202122232425262728293031class Animal &#123; name:string constructor(name:string) &#123; this.name = name &#125; eat() &#123; console.log(&apos;eat ---- &apos;) &#125;&#125;class Dog extends Animal &#123; constructor (name: string) &#123; super(name) &#125; eat() &#123; return this.name + &apos;吃东西&apos; &#125;&#125;class Cat extends Animal &#123; constructor (name: string) &#123; super(name) &#125; eat() &#123; return this.name + &apos;吃猫粮&apos; &#125;&#125; 抽象类 它是提供其他继承的基类,不能直接被实例化 用abstract关键字定义抽象类和抽象方法,抽象类中的抽象方法不包含具体实现并且必须在派生类中实现 abstract 抽象方法只能放在抽象类里面 抽象类和抽象方法用来定义标准 123456789101112131415161718192021222324252627282930// 标准: Animal 这个类要求它的子类必须包含 eat 方法abstract class Animal &#123; name:string constructor(name:string) &#123; this.name = name &#125; // 其他抽象类子类必须实现此方法 abstract eat():any &#123; console.log(&apos;eat ---- &apos;) &#125; // 其他方法可以不用实现 run() &#123;&#125;&#125;// var a = new Animal() // 错误写法class Dog extends Animal &#123; constructor (name: any) &#123; super(name) &#125; eat() &#123; console.log(`$&#123;this.name&#125;吃狗粮`) &#125;&#125;const dog = new Animal(&apos;dog&apos;)d.eat() typescript 接口 属性类接口 函数类型接口 可索引接口 类类型接口 接口扩展 属性接口 自定义方法传入参数,对json的约束 1234567function printLabel(&#123;labelInfo: &#123;label:string&#125;&#125;):void &#123; console.log(&apos;printLabel&apos;)&#125;// printLabel(&apos;hhh&apos;) // 错误写法// printLabel(&#123;name: &apos;xiao&apos;&#125;) // 错误写法printLabel(&#123;label: &apos;xiao ming&apos;&#125;) // 正确 对批量方法传入参数进行约束, 必须有关键字interface 12345678910111213141516171819202122232425262728interface FullName &#123; firstName: string; // 注意: 一定是 `;`结束 secondName: string;&#125;function printName(name: FullName) &#123; console.log(`$&#123;name.firstName&#125;----$&#123;name.secondName&#125; )&#125;function printInfo(info: FullName) &#123; console.log(`$&#123;info.firstName&#125;----$&#123;info.secondName&#125; )&#125;var obj = &#123; age: 20, firstName : &apos;xiao&apos;, secondName: &apos;ming&apos;&#125;var info = &#123; firstName : &apos;xiao&apos;, secondName: &apos;ming&apos;&#125;printName(obj)printInfo(info) 函数类型接口 对方法传入的参数以及返回值进行约束 123456789interface encrypt &#123; (key:string, value:string):string&#125;var md5:encrypt = function(key:string, value:string):string &#123; return key+value&#125;console.log(md5(&apos;name&apos;, &apos;xiao&apos;)) 可索引接口 对数组对象约束,不常用 12345678910111213141516171819202122// ts 定义数组方式var arr:number[] = [12, 23]var arr1:Array&lt;string&gt;=[&apos;12&apos;, &apos;23&apos;]// 对数组约束interface UserArr &#123; [index: number]:string&#125;var arr2:UserArr = [&apos;aaa&apos;, &apos;bbb&apos;]console.log(arr2[0])// 对对象约束interface UserObj &#123; [index:string]:string&#125;var arr3:UserObj = [name: &apos;xiao ming&apos;]console.log(arr3) 类类型接口 对类的约束和抽象类有点相似 1234567891011121314151617181920interface Animal &#123; name: string eat(str: string): void&#125;class Dog implements Animal &#123; name: string constructor(name: string) &#123; this.name = name &#125; eat() &#123; console.log(this.name + &apos;吃狗粮&apos;) &#125;&#125;var d = new Dog(&apos;dog&apos;)d.eat() 接口扩展 接口可以继承接口 1234567891011121314151617181920212223242526interface Animal &#123; eat(): void&#125;interface Person extends Animal &#123; word(): void&#125;class Web implements Person &#123; public name:string constructor(name:string) &#123; this.name = name &#125; eat() &#123; console.log(this.name + &apos;吃中餐&apos;) &#125; work() &#123; console.log(this.name + &apos;工作&apos;) &#125;&#125;var w = new Web(&apos;xiao ku&apos;)w.eat() 1234567891011121314151617181920212223242526272829303132333435interface Animal &#123; eat(): void&#125;interface Person extends Animal &#123; work(): void&#125;class Programmer &#123; public name: string constructor(name: string) &#123; this.name = name &#125; coding(code: string) &#123; console.log(this.name + code) &#125;&#125;class Web extends Programmer implements Person &#123; constructor(name: string) &#123; super(name) &#125; eat() &#123; console.log(this.name + &apos;喜欢吃馒头&apos;) &#125; work() &#123; console.log(this.name + &apos;写代码&apos;) &#125;&#125;var w = new Web(&apos;小李&apos;)// w.eat()w.coding(&apos;敲代码&apos;) typescript 泛型 泛型的定义 泛型函数 泛型类 泛型接口 泛型定义 泛型:软件工程中,不仅要创建一致定义良好的API, 组件不仅能够支持当前的数据类型,同事也能支持未来的数据类型,这在创建大型系统时为你提供十分灵活的功能 就是解决类接口,方法的复用性,以及对不特定数据类型的支持(类型校验) 可以支持不特定的数据类型, 但传入的参数和返回的参数一致 T表示泛型,具体什么类型是调用这个方法的时候决定的 泛型函数123456789101112131415function getData&lt;T&gt;(value:T):T &#123; return value&#125;getDate&lt;number&gt;(123) // 正确getDate&lt;number&gt;(&apos;123&apos;) // 错误// any 返回指定值不报错,通常推荐以上写法function getData&lt;T&gt;(value:T):any &#123; return value&#125;getDate&lt;number&gt;(123)getDate&lt;string&gt;(&apos;123&apos;) 泛型类 比如有个最小堆算法,需要同时支持返回数字和字符串两种类型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class MinClass &#123; public list: number[] = [] add(num: number) &#123; this.list.push(num) &#125; min() &#123; var minNum = this.list[0] for (var i = 0; i &lt; this.list.length; i++) &#123; if (minNum &gt; this.list[i]) &#123; minNum = this.list[i] &#125; &#125; return minNum &#125;&#125;var m = new MinClass()m.add(289)m.add(22)m.add(23)m.add(28)console.log(m.min())// ts写法class MinClass&lt;T&gt; &#123; public list: T[] = [] add(value:T):void &#123; this.list.push(value) &#125; min():T &#123; var minNum = this.list[0] for (var i = 0; i &lt; this.list.length; i++) &#123; if (minNum &gt; this.list[i]) &#123; minNum = this.list[i] &#125; &#125; return minNum &#125;&#125;var m1 = new MinClass&lt;number&gt;() // 实例化类, 并且指定了类的T代表类型是numberm1.add(29)m1.add(22)console.log(m1.min())``` #### 泛型接口 函数类型接口interface ConfigFn { (value1:string, value2 :string):string} var setData:configFn = function(value1:string,value2:string) { return value1+value2} setData(‘name’, ‘xiao ming’) // 1.泛型接口interface ConfigFn { (value:T):T} var getData1:ConfigFn = function(value:T):T { return value} getData1(‘xiao xiao’) // 2.泛型接口interface ConfigFn { (value:T):T} function getData3(value:T):T { return value} var myGetData:ConfigFn = getData3myGetData(‘xiao hong’)`","categories":[],"tags":[{"name":"study | typescript","slug":"study-typescript","permalink":"https://ai-ruby.github.io/tags/study-typescript/"}]},{"title":"Mac 使用Hexo + github 搭建个人博客详解","slug":"init hexo","date":"2018-04-03T03:32:40.613Z","updated":"2018-07-27T04:03:47.939Z","comments":true,"path":"2018/04/03/init hexo/","link":"","permalink":"https://ai-ruby.github.io/2018/04/03/init hexo/","excerpt":"","text":"在Mac平台通过Hexo + github 搭建个人博客 Hexo 安装流程环境配置 node.js 官网 git 官网 具体怎么安装就不细说了,在准备环境搭建好之后,就可以开始使用Hexo搭建博客了 安装Hexo 当Node.js和git都安装好了,就可以安装 Hexo, 在终端执行以下命令 1npm install -g hexo-cli/Users/ruai/projects/blogs/hexo-blogs/source/_posts/Typescript.md Hexo初始化 在自己项目目录下新建一个文件夹 123hexo initnpm install ==&gt; 简写 npm ihexo server ==&gt; 简写 hexo s 此时在浏览器中打开网址http://localhost:4000 就可以看到一个静态网页 Hexo文件夹目录结构 source：博客资源文件夹 source/_drafts：草稿文件夹 source/_posts：文章文件夹 themes：存放主题的文件夹 themes/landscape：默认的主题 _config.yml：全局配置文件 部署到Github Pages 创建github账号并创建repository 博客发布到Github Pages上，供外网访问，当然你也可以部署到其他服务器上，Github Pages服务的使用步骤： 开通Github账号，例如我的账号名CSDNHensen，这个后面会用到 创建一个repository，名称开头必须和账号名一样，然后以.github.io结尾 修改hexo的配置文件 修改配置文件：_config.yml，整个站点的配置都在这里，打开_config.yml文件 找到下面的语句，然后修改你的信息，repository在github仓库中可以复制 github或者是coding 也行, 我是使用github的 123456deploy: type: git repository: github: https://github.com/github名/github名.github.io coding: https://git.coding.net/coding/coding.coding.me.git branch: master 注意项: 注意：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错.* 修改Hexo主题 下载喜欢的主题 可到 Hexo官网themes 选择喜欢的主题 本主题是 tomotoes 在项目执行以下命令1git clone https://github.com/Tomotoes/hexo-theme-tomotoes themes/tomotoes 在配置文件下修改themes 在项目_config.yml 找到 themes修改为tomotoes 可查看主题文档安装,以下不细说 建立博客新建博客 发布博客有两种方式: 一:通过命令行生成博客样板; 二:直接用markdown文档写完后放置/source/_posts目录下 1hexo new HelloWord 新生成的文章都会保存在/source/_posts目录下，打开生成的模板，内容如下 1234---title: Mac 使用Hexo + github 搭建个人博客详解abbrlink: 16107--- 生成博客 新增了博客文章后，需要提交到服务器上，输入以下指令完成将博客生成静态Html文件 1hexo generate hexo generate 简写 hexo g 发布博客到服务器 安装hexo-deployer-git工具，输入指令如果是第一次发布的需要安装hexo-deployer-git工具 1npm install hexo-deployer-git --save 提交到服务器上，提交过程中还需要输入github账号和密码 1hexo deploy hexo deploy 简写 hexo d 终端cd到blog目录下执行如下命令(每次部署文章的步骤)： 123hexo clean // 清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo g // 生成缓存和静态文件hexo d // 重新部署到服务器 Hexo快捷命令Hexo常用命令12345hexo new &quot;postName&quot; //新建文章hexo new page &quot;pageName&quot; //新建页面hexo generate //生成静态页面至public目录hexo server //开启预览访问端口（默认端口4000，ctrl+c关闭server）hexo deploy //将.deploy目录部署到服务器 简写 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 快捷简写 12hexo d -g == hexo deploy -generatehexo g -d == hexo -deploy -deploy","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://ai-ruby.github.io/tags/hexo/"}]}]}